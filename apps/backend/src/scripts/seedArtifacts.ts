/**
 * Seed Artifacts
 * 
 * Seeds all artifacts from various systems into the unified Artifact model.
 * This creates artifacts from:
 * - Static core artifacts (Resources, Stats, Systems, Concepts, Laws)
 * - Loadout items (Weapons)
 * - Reality Nodes (Laws, Principles, Agents, Environments)
 * - Money system (Agents, Teams, Products)
 * - Training modules
 * - Health knowledge
 * - Awareness layers
 * 
 * Also seeds artifact relationships (graph edges).
 */

import { PrismaClient, ArtifactCategory } from '@prisma/client'

const prisma = new PrismaClient()

/**
 * Create or update an artifact with upsert logic
 */
async function upsertArtifact(data: {
  systemId: string | null
  systemType: string | null
  sourceId: string | null
  title: string
  description?: string | null
  category: ArtifactCategory
  iconName?: string | null
  route?: string | null
  tags?: string[]
  metadata?: any
  orderIndex?: number
  realityNodeId?: string | null
}) {
  // For static artifacts, use 'static' as systemId and title-based sourceId
  // For system artifacts, use provided values
  const finalSystemId = data.systemId || 'static'
  const finalSystemType = data.systemType || 'artifact'
  const finalSourceId = data.sourceId || `static-${data.title.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '')}`

  // First try to find existing by unique constraint
  const existing = await prisma.artifact.findUnique({
    where: {
      systemId_systemType_sourceId: {
        systemId: finalSystemId,
        systemType: finalSystemType,
        sourceId: finalSourceId,
      },
    },
  })

  if (existing) {
    // Update existing
    return await prisma.artifact.update({
      where: { id: existing.id },
      data: {
        title: data.title,
        description: data.description,
        category: data.category,
        iconName: data.iconName,
        route: data.route,
        tags: data.tags || [],
        metadata: data.metadata,
        orderIndex: data.orderIndex ?? 0,
        realityNodeId: data.realityNodeId,
        isActive: true,
      },
    })
  } else {
    // Create new
    return await prisma.artifact.create({
      data: {
        systemId: finalSystemId,
        systemType: finalSystemType,
        sourceId: finalSourceId,
        title: data.title,
        description: data.description,
        category: data.category,
        iconName: data.iconName,
        route: data.route,
        tags: data.tags || [],
        metadata: data.metadata,
        orderIndex: data.orderIndex ?? 0,
        realityNodeId: data.realityNodeId,
        isActive: true,
      },
    })
  }
}

/**
 * Seed static core artifacts (Resources, Stats, Systems, Concepts, Laws)
 */
async function seedStaticArtifacts() {
  console.log('\nðŸ“¦ Seeding static core artifacts...')

  // Resources
  await upsertArtifact({
    systemId: 'static',
    systemType: 'resource',
    sourceId: null,
    title: 'Energy',
    description: 'Daily budget that enables all system operations. Energy powers Finance, Health, and other systems, forcing prioritization of high-value activities across competing demands.',
    category: ArtifactCategory.RESOURCE,
    iconName: 'Zap',
    tags: ['daily', 'scarcity', 'action', 'systems'],
    metadata: {
      details: [
        'Enables actions across all systems',
        'Systems consume energy for operations',
        'Resets at daily tick',
        'Cannot stack across days',
        'Modified by Capacity stat',
        'Every action requires Energy',
        'Forces prioritization across competing systems'
      ],
      references: ['capacity', 'water', 'armor']
    },
    orderIndex: 1,
  })

  await upsertArtifact({
    systemId: 'static',
    systemType: 'resource',
    sourceId: null,
    title: 'Money (Gold)',
    description: 'Currency of the Power Game. Enables influence, control, and expansion of options.',
    category: ArtifactCategory.RESOURCE,
    iconName: 'DollarSign',
    tags: ['currency', 'influence', 'power'],
    metadata: {
      route: '/finance',
      details: [
        'Primary currency of influence',
        'Generated by Engines',
        'Used for investments',
        'Enables risk-taking when combined with Oxygen',
        'Cannot provide meaning or identity'
      ]
    },
    orderIndex: 2,
  })

  await upsertArtifact({
    systemId: 'static',
    systemType: 'resource',
    sourceId: null,
    title: 'Oxygen',
    description: 'Months of expenses saved. Enables risk-taking and provides security buffer.',
    category: ArtifactCategory.RESOURCE,
    iconName: 'Droplet',
    tags: ['savings', 'security', 'risk'],
    metadata: {
      details: [
        'Measured in months of expenses',
        'Enables risk-taking',
        'Provides security buffer',
        'Critical for survival'
      ]
    },
    orderIndex: 3,
  })

  await upsertArtifact({
    systemId: 'static',
    systemType: 'resource',
    sourceId: null,
    title: 'Water',
    description: 'Hydration level affecting system performance and capacity.',
    category: ArtifactCategory.RESOURCE,
    iconName: 'Droplet',
    tags: ['health', 'performance'],
    orderIndex: 4,
  })

  await upsertArtifact({
    systemId: 'static',
    systemType: 'resource',
    sourceId: null,
    title: 'Armor',
    description: 'Protection against burnout and system degradation.',
    category: ArtifactCategory.RESOURCE,
    iconName: 'Shield',
    tags: ['protection', 'burnout', 'resilience'],
    orderIndex: 5,
  })

  await upsertArtifact({
    systemId: 'static',
    systemType: 'resource',
    sourceId: null,
    title: 'Keys',
    description: 'Special items that unlock new capabilities and paths.',
    category: ArtifactCategory.RESOURCE,
    iconName: 'Key',
    tags: ['unlock', 'capabilities'],
    orderIndex: 6,
  })

  // Stats
  await upsertArtifact({
    systemId: 'static',
    systemType: 'stat',
    sourceId: null,
    title: 'Capacity',
    description: 'Foundation for system performance. High Capacity enables sustained operation across Finance, Health, and Energy systems.',
    category: ArtifactCategory.STAT,
    iconName: 'HeartPulse',
    tags: ['health', 'resilience', 'survival', 'systems'],
    metadata: {
      details: [
        'Range: 0-100',
        'Modifies usable Energy cap across all systems',
        'Low Capacity = degraded system performance',
        'Governs burnout resistance for all operations',
        'Supports sustained system execution',
        'Critical for multi-system coordination'
      ],
      references: ['energy', 'water', 'armor', 'meaning']
    },
    orderIndex: 10,
  })

  await upsertArtifact({
    systemId: 'static',
    systemType: 'stat',
    sourceId: null,
    title: 'Engines',
    description: 'Income-generating activities and systems that produce Money.',
    category: ArtifactCategory.STAT,
    iconName: 'TrendingUp',
    tags: ['income', 'generation', 'systems'],
    orderIndex: 11,
  })

  await upsertArtifact({
    systemId: 'static',
    systemType: 'stat',
    sourceId: null,
    title: 'Meaning',
    description: 'Purpose and significance that drives motivation and engagement.',
    category: ArtifactCategory.STAT,
    iconName: 'Brain',
    tags: ['purpose', 'motivation'],
    orderIndex: 12,
  })

  await upsertArtifact({
    systemId: 'static',
    systemType: 'stat',
    sourceId: null,
    title: 'Optionality',
    description: 'Freedom and choices available, enabling flexible decision-making.',
    category: ArtifactCategory.STAT,
    iconName: 'Sparkles',
    tags: ['freedom', 'choices', 'flexibility'],
    orderIndex: 13,
  })

  // Systems
  await upsertArtifact({
    systemId: 'static',
    systemType: 'system',
    sourceId: null,
    title: 'Money System',
    description: 'Complete financial management system with agents, teams, and products.',
    category: ArtifactCategory.SYSTEM,
    iconName: 'DollarSign',
    route: '/finance',
    tags: ['finance', 'money', 'management'],
    orderIndex: 20,
  })

  await upsertArtifact({
    systemId: 'static',
    systemType: 'system',
    sourceId: null,
    title: 'Energy System',
    description: 'Daily energy budget and capacity management system.',
    category: ArtifactCategory.SYSTEM,
    iconName: 'Zap',
    tags: ['energy', 'capacity', 'management'],
    orderIndex: 21,
  })

  // Concepts
  await upsertArtifact({
    systemId: 'static',
    systemType: 'concept',
    sourceId: null,
    title: 'Tier System',
    description: 'Hierarchical organization of systems by importance and survival necessity.',
    category: ArtifactCategory.CONCEPT,
    iconName: 'Target',
    tags: ['hierarchy', 'organization', 'priority'],
    orderIndex: 30,
  })

  // Laws
  await upsertArtifact({
    systemId: 'static',
    systemType: 'law',
    sourceId: null,
    title: '48 Laws of Power',
    description: 'Immutable laws governing power dynamics and strategic behavior.',
    category: ArtifactCategory.LAW,
    iconName: 'BookOpen',
    tags: ['power', 'strategy', 'laws'],
    orderIndex: 40,
  })

  await upsertArtifact({
    systemId: 'static',
    systemType: 'law',
    sourceId: null,
    title: 'Bible Laws',
    description: 'Biblical principles applied to modern life and decision-making.',
    category: ArtifactCategory.LAW,
    iconName: 'BookOpen',
    tags: ['biblical', 'principles', 'laws'],
    orderIndex: 41,
  })

  console.log('  âœ… Static core artifacts seeded')
}

/**
 * Seed artifacts from Loadout system (Weapons)
 */
async function seedLoadoutArtifacts() {
  console.log('\nâš”ï¸  Seeding loadout artifacts (weapons)...')

  const loadoutItems = await prisma.loadoutItem.findMany({
    where: { isDefault: true },
    orderBy: { name: 'asc' },
  })

  for (const item of loadoutItems) {
    await upsertArtifact({
      systemId: 'loadout',
      systemType: 'weapon',
      sourceId: item.id,
      title: item.name,
      description: item.description,
      category: ArtifactCategory.WEAPON,
      iconName: 'Sword',
      route: '/loadout',
      tags: ['weapon', 'loadout', 'capability', item.slotType.toLowerCase()],
      metadata: {
        powerLevel: item.powerLevel,
        benefits: item.benefits,
        slotType: item.slotType,
        isDefault: item.isDefault,
      },
      orderIndex: 100 + item.powerLevel,
    })
  }

  console.log(`  âœ… Seeded ${loadoutItems.length} loadout artifacts`)
}

/**
 * Seed artifacts from Reality Nodes
 */
async function seedRealityNodeArtifacts() {
  console.log('\nðŸŒ³ Seeding reality node artifacts...')

  // Get all laws and principles from reality hierarchy
  const lawsAndPrinciples = await prisma.realityNode.findMany({
    where: {
      nodeType: {
        in: ['LAW', 'PRINCIPLE'],
      },
    },
    orderBy: { orderIndex: 'asc' },
  })

  for (const node of lawsAndPrinciples) {
    const category = node.nodeType === 'LAW' 
      ? ArtifactCategory.LAW 
      : ArtifactCategory.PRINCIPLE

    await upsertArtifact({
      systemId: 'reality',
      systemType: node.nodeType.toLowerCase(),
      sourceId: node.id,
      title: node.title,
      description: node.description || undefined,
      category,
      iconName: node.nodeType === 'LAW' ? 'BookOpen' : 'Lightbulb',
      tags: ['reality', node.nodeType.toLowerCase(), ...(node.category ? [node.category.toLowerCase()] : [])],
      metadata: node.metadata,
      realityNodeId: node.id,
      orderIndex: node.orderIndex + 500,
    })
  }

  console.log(`  âœ… Seeded ${lawsAndPrinciples.length} reality node artifacts`)
}

/**
 * Seed artifacts from Money system (Agents, Teams, Products)
 */
async function seedMoneySystemArtifacts() {
  console.log('\nðŸ’° Seeding money system artifacts...')

  // Agents
  const agents = await prisma.agent.findMany({
    orderBy: { order: 'asc' },
  })

  for (const agent of agents) {
    await upsertArtifact({
      systemId: 'money',
      systemType: 'agent',
      sourceId: agent.id,
      title: agent.name,
      description: agent.description,
      category: ArtifactCategory.CONCEPT,
      iconName: 'Network',
      route: '/finance',
      tags: ['money', 'agent', 'finance'],
      metadata: {
        type: agent.type,
        expertise: agent.expertise,
        metadata: agent.metadata,
      },
      orderIndex: 200 + agent.order,
    })
  }

  // Teams
  const teams = await prisma.team.findMany({
    orderBy: { order: 'asc' },
  })

  for (const team of teams) {
    await upsertArtifact({
      systemId: 'money',
      systemType: 'team',
      sourceId: team.id,
      title: team.name,
      description: team.description,
      category: ArtifactCategory.SYSTEM,
      iconName: 'Network',
      route: '/finance',
      tags: ['money', 'team', 'finance'],
      metadata: {
        domain: team.domain,
      },
      orderIndex: 300 + team.order,
    })
  }

  // Products
  const products = await prisma.product.findMany({
    where: { isActive: true },
    orderBy: { order: 'asc' },
  })

  for (const product of products) {
    await upsertArtifact({
      systemId: 'money',
      systemType: 'product',
      sourceId: product.id,
      title: product.name,
      description: product.description,
      category: ArtifactCategory.CONCEPT,
      iconName: 'Target',
      route: product.url || '/finance',
      tags: ['money', 'product', 'finance', product.type.toLowerCase()],
      metadata: {
        type: product.type,
        features: product.features,
        integrationPoints: product.integrationPoints,
      },
      orderIndex: 400 + product.order,
    })
  }

  console.log(`  âœ… Seeded ${agents.length} agents, ${teams.length} teams, ${products.length} products`)
}

/**
 * Seed artifact relationships
 */
async function seedArtifactRelationships() {
  console.log('\nðŸ”— Seeding artifact relationships...')

  // Find artifacts by their identifiers
  const energyArtifact = await prisma.artifact.findFirst({
    where: { title: 'Energy', systemId: 'static', systemType: 'resource' },
  })

  const capacityArtifact = await prisma.artifact.findFirst({
    where: { title: 'Capacity', systemId: 'static', systemType: 'stat' },
  })

  const moneyArtifact = await prisma.artifact.findFirst({
    where: { title: 'Money (Gold)', systemId: 'static', systemType: 'resource' },
  })

  const waterArtifact = await prisma.artifact.findFirst({
    where: { title: 'Water', systemId: 'static', systemType: 'resource' },
  })

  const armorArtifact = await prisma.artifact.findFirst({
    where: { title: 'Armor', systemId: 'static', systemType: 'resource' },
  })

  // Create relationships
  if (energyArtifact && capacityArtifact) {
    await prisma.artifactReference.upsert({
      where: {
        fromId_toId_type: {
          fromId: energyArtifact.id,
          toId: capacityArtifact.id,
          type: 'enhances',
        },
      },
      update: { strength: 0.8 },
      create: {
        fromId: energyArtifact.id,
        toId: capacityArtifact.id,
        type: 'enhances',
        strength: 0.8,
      },
    })
  }

  if (capacityArtifact && energyArtifact) {
    await prisma.artifactReference.upsert({
      where: {
        fromId_toId_type: {
          fromId: capacityArtifact.id,
          toId: energyArtifact.id,
          type: 'modifies',
        },
      },
      update: { strength: 0.9 },
      create: {
        fromId: capacityArtifact.id,
        toId: energyArtifact.id,
        type: 'modifies',
        strength: 0.9,
      },
    })
  }

  if (capacityArtifact && waterArtifact) {
    await prisma.artifactReference.upsert({
      where: {
        fromId_toId_type: {
          fromId: capacityArtifact.id,
          toId: waterArtifact.id,
          type: 'related',
        },
      },
      update: { strength: 0.6 },
      create: {
        fromId: capacityArtifact.id,
        toId: waterArtifact.id,
        type: 'related',
        strength: 0.6,
      },
    })
  }

  if (capacityArtifact && armorArtifact) {
    await prisma.artifactReference.upsert({
      where: {
        fromId_toId_type: {
          fromId: capacityArtifact.id,
          toId: armorArtifact.id,
          type: 'related',
        },
      },
      update: { strength: 0.6 },
      create: {
        fromId: capacityArtifact.id,
        toId: armorArtifact.id,
        type: 'related',
        strength: 0.6,
      },
    })
  }

  console.log('  âœ… Artifact relationships seeded')
}

/**
 * Main seeding function
 */
export async function seedArtifacts() {
  console.log('\nðŸŽ¨ Starting artifact seeding...')
  console.log('â•'.repeat(60))

  try {
    await seedStaticArtifacts()
    await seedLoadoutArtifacts()
    await seedRealityNodeArtifacts()
    await seedMoneySystemArtifacts()
    await seedArtifactRelationships()

    // Summary
    const counts = await Promise.all([
      prisma.artifact.count(),
      prisma.artifactReference.count(),
    ])

    console.log('\n' + 'â•'.repeat(60))
    console.log('âœ… Artifact seeding completed!')
    console.log(`   Total artifacts: ${counts[0]}`)
    console.log(`   Total relationships: ${counts[1]}`)
    console.log('â•'.repeat(60))
  } catch (error) {
    console.error('âŒ Error seeding artifacts:', error)
    throw error
  }
}

// Allow running standalone
if (import.meta.url === `file://${process.argv[1]}`) {
  seedArtifacts()
    .catch((e) => {
      console.error(e)
      process.exit(1)
    })
    .finally(async () => {
      await prisma.$disconnect()
    })
}

export default seedArtifacts

